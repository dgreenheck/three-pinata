<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Annulus Triangulation Debug</title>
    <style>
        body {
            margin: 0;
            font-family: monospace;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 400px;
        }
        #canvas {
            width: 100%;
            height: 100vh;
        }
        .warning {
            color: #ff6b6b;
            font-weight: bold;
        }
        .valid {
            color: #51cf66;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Annulus Triangulation Debug</h3>
        <div id="stats"></div>
    </div>
    <canvas id="canvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three-pinata": "./lib/build/three-pinata.es.js"
        }
    }
    </script>
    <script type="module">
        import { Vector2, Vector3 } from 'three';
        import { ConstrainedTriangulator, MeshVertex, EdgeConstraint } from 'three-pinata';

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statsDiv = document.getElementById('stats');

        let triangulationResult = null;

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Configuration
        const outerRadius = 2;
        const innerRadius = 1;
        const segments = 8;

        // Center of canvas
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const scale = 150; // pixels per unit

        // Build the annulus data
        const vertices = [];
        const constraints = [];
        const meshVertices = [];
        const edgeConstraints = [];

        // Outer circle (CCW)
        for (let i = 0; i < segments; i++) {
            const angle = (i / segments) * 2 * Math.PI;
            const x = Math.cos(angle) * outerRadius;
            const y = Math.sin(angle) * outerRadius;

            vertices.push({
                x: x,
                y: y,
                index: i,
                type: 'outer'
            });

            meshVertices.push(new MeshVertex(
                new Vector3(x, 0, y),
                new Vector3(0, 1, 0),
                new Vector2()
            ));
        }

        // Add outer constraints
        for (let i = 0; i < segments; i++) {
            const v1 = i;
            const v2 = (i + 1) % segments;
            constraints.push({ v1, v2, type: 'outer' });
            edgeConstraints.push(new EdgeConstraint(v1, v2));
        }

        // Inner circle (CW - opposite winding for hole)
        const innerOffset = segments;
        for (let i = 0; i < segments; i++) {
            const angle = (i / segments) * 2 * Math.PI;
            const x = Math.cos(angle) * innerRadius;
            const y = Math.sin(angle) * innerRadius;

            vertices.push({
                x: x,
                y: y,
                index: innerOffset + i,
                type: 'inner'
            });

            meshVertices.push(new MeshVertex(
                new Vector3(x, 0, y),
                new Vector3(0, 1, 0),
                new Vector2()
            ));
        }

        // Add inner constraints (CW)
        for (let i = 0; i < segments; i++) {
            const v1 = innerOffset + i;
            const v2 = innerOffset + ((i + 1) % segments);
            constraints.push({ v1: v2, v2: v1, type: 'inner' }); // Reversed for CW
            edgeConstraints.push(new EdgeConstraint(v2, v1)); // Reversed for CW
        }

        // Run triangulation
        const triangulator = new ConstrainedTriangulator(
            meshVertices,
            edgeConstraints,
            new Vector3(0, -1, 0)
        );
        const triangles = triangulator.triangulate();

        console.log('Triangulation result:', triangles);
        console.log('Number of triangles:', triangles.length / 3);

        // Transform to canvas coordinates
        function toCanvas(x, y) {
            return {
                x: cx + x * scale,
                y: cy - y * scale // Flip Y for canvas
            };
        }

        // Draw
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = -5; i <= 5; i++) {
                const p1 = toCanvas(-5, i);
                const p2 = toCanvas(5, i);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();

                const p3 = toCanvas(i, -5);
                const p4 = toCanvas(i, 5);
                ctx.beginPath();
                ctx.moveTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.stroke();
            }

            // Draw triangles
            if (triangles.length > 0) {
                for (let i = 0; i < triangles.length; i += 3) {
                    const v1 = vertices[triangles[i]];
                    const v2 = vertices[triangles[i + 1]];
                    const v3 = vertices[triangles[i + 2]];

                    const p1 = toCanvas(v1.x, v1.y);
                    const p2 = toCanvas(v2.x, v2.y);
                    const p3 = toCanvas(v3.x, v3.y);

                    // Calculate centroid to check if in hole
                    const cx = (v1.x + v2.x + v3.x) / 3;
                    const cy = (v1.y + v2.y + v3.y) / 3;
                    const distFromOrigin = Math.sqrt(cx * cx + cy * cy);

                    // Color based on whether triangle is in valid region
                    const inHole = distFromOrigin < innerRadius * 0.9;
                    const outsideBounds = distFromOrigin > outerRadius * 1.1;

                    if (inHole || outsideBounds) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.2)'; // Red for invalid
                    } else {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.1)'; // Green for valid
                    }

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.closePath();
                    ctx.fill();

                    // Draw triangle edges
                    ctx.strokeStyle = inHole || outsideBounds ? 'rgba(255, 0, 0, 0.5)' : 'rgba(0, 255, 0, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            // Draw constraint edges
            ctx.lineWidth = 3;
            constraints.forEach((constraint, idx) => {
                const v1 = vertices[constraint.v1];
                const v2 = vertices[constraint.v2];
                const p1 = toCanvas(v1.x, v1.y);
                const p2 = toCanvas(v2.x, v2.y);

                ctx.strokeStyle = constraint.type === 'outer' ? '#4dabf7' : '#ff6b6b';
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();

                // Draw arrow to show direction
                const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                const arrowLen = 15;

                ctx.beginPath();
                ctx.moveTo(midX, midY);
                ctx.lineTo(
                    midX - arrowLen * Math.cos(angle - Math.PI / 6),
                    midY - arrowLen * Math.sin(angle - Math.PI / 6)
                );
                ctx.moveTo(midX, midY);
                ctx.lineTo(
                    midX - arrowLen * Math.cos(angle + Math.PI / 6),
                    midY - arrowLen * Math.sin(angle + Math.PI / 6)
                );
                ctx.stroke();
            });

            // Draw vertices
            vertices.forEach(v => {
                const p = toCanvas(v.x, v.y);
                ctx.fillStyle = v.type === 'outer' ? '#4dabf7' : '#ff6b6b';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, 2 * Math.PI);
                ctx.fill();

                // Draw index
                ctx.fillStyle = 'white';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(v.index.toString(), p.x, p.y);
            });

            // Draw angle labels for debugging
            ctx.fillStyle = '#aaa';
            ctx.font = '10px monospace';
            vertices.forEach((v, i) => {
                if (i < segments || i % 2 === 0) {
                    const angle = Math.atan2(v.y, v.x);
                    const deg = (angle * 180 / Math.PI).toFixed(0);
                    const p = toCanvas(v.x * 1.3, v.y * 1.3);
                    ctx.fillText(`${deg}°`, p.x, p.y);
                }
            });
        }

        // Generate stats
        let statsHTML = '<div><strong>Configuration:</strong></div>';
        statsHTML += `<div>Segments: ${segments}</div>`;
        statsHTML += `<div>Outer radius: ${outerRadius}</div>`;
        statsHTML += `<div>Inner radius: ${innerRadius}</div>`;
        statsHTML += '<br>';

        statsHTML += '<div><strong>Triangulation:</strong></div>';
        statsHTML += `<div>Total triangles: ${triangles.length / 3}</div>`;

        // Count valid vs invalid triangles
        let validCount = 0;
        let inHoleCount = 0;
        let outsideCount = 0;
        for (let i = 0; i < triangles.length; i += 3) {
            const v1 = vertices[triangles[i]];
            const v2 = vertices[triangles[i + 1]];
            const v3 = vertices[triangles[i + 2]];
            const cx = (v1.x + v2.x + v3.x) / 3;
            const cy = (v1.y + v2.y + v3.y) / 3;
            const dist = Math.sqrt(cx * cx + cy * cy);

            if (dist < innerRadius * 0.9) inHoleCount++;
            else if (dist > outerRadius * 1.1) outsideCount++;
            else validCount++;
        }
        statsHTML += `<div class="valid">✓ Valid (in ring): ${validCount}</div>`;
        if (inHoleCount > 0) {
            statsHTML += `<div class="warning">✗ In hole: ${inHoleCount}</div>`;
        }
        if (outsideCount > 0) {
            statsHTML += `<div class="warning">✗ Outside: ${outsideCount}</div>`;
        }
        statsHTML += '<br>';

        statsHTML += '<div><strong>Outer Constraints (CCW - Blue):</strong></div>';
        statsHTML += '<div style="font-size: 11px;">';
        const outerConstraints = constraints.filter(c => c.type === 'outer');
        statsHTML += outerConstraints.map(c => `${c.v1}→${c.v2}`).join(', ');
        statsHTML += '</div><br>';

        statsHTML += '<div><strong>Inner Constraints (CW - Red):</strong></div>';
        statsHTML += '<div style="font-size: 11px;">';
        const innerConstraints = constraints.filter(c => c.type === 'inner');
        statsHTML += innerConstraints.map(c => `${c.v1}→${c.v2}`).join(', ');
        statsHTML += '</div><br>';

        // Check if inner forms proper loop
        statsHTML += '<div><strong>Inner Constraint Chain:</strong></div>';
        statsHTML += '<div style="font-size: 11px;">';
        let current = innerConstraints[0].v1;
        let chain = [current];
        for (let i = 0; i < innerConstraints.length; i++) {
            const next = innerConstraints.find(c => c.v1 === current);
            if (next) {
                current = next.v2;
                chain.push(current);
            }
        }
        statsHTML += chain.join(' → ');
        statsHTML += '</div>';

        statsDiv.innerHTML = statsHTML;

        draw();

        // Redraw on resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        });
    </script>
</body>
</html>
